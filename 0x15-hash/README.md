# [해시 (Hash) 자료구조: 빠르고 효율적인 데이터 관리의 핵심](../workbook/0x15.md)

해시(Hash)는 **해시 테이블(Hash Table)**이라는 자료구조를 지칭하며, 키(key)에 대응하는 값(value)을 저장하는 **키-값 쌍(key-value pair)** 형태의 데이터를 관리하는 데 특화되어 있습니다.

우리가 일상에서 흔히 접하는 비유를 통해 해시의 기본적인 아이디어를 이해해 볼 수 있습니다. 예를 들어, 여러 사람의 긴 카드 번호와 그 소유자의 이름을 기억해야 한다고 상상해 봅시다.

```
2621 6189 5198 5135 - Kim
3727 2380 0612 2168 - Park
8910 2829 6281 1921 - Lee
2077 2610 4780 5305 - Ko
```

16자리의 긴 카드 번호 전체를 하나하나 외우는 것은 비효율적입니다. 대신 우리는 보통 카드 번호의 일부, 예를 들어 마지막 네 자리 숫자만 기억하더라도 해당 카드 번호가 누구의 것인지 빠르게 알아낼 수 있습니다. 물론 마지막 네 자리가 중복될 경우 문제가 발생할 수도 있지만, 특정 규칙(해시 함수)을 통해 짧은 정보를 만들고, 이를 원래의 긴 정보(키)와 연결하는 이 과정이 바로 해시 자료구조의 근본 원리와 맞닿아 있습니다.

여기서 카드 번호는 'key' 역할을 하고, 사람의 이름은 'value' 역할을 합니다. 우리는 새로운 카드 번호와 이름 쌍을 추가하거나, 특정 카드 번호를 이용해 해당 소유자의 이름을 빠르게 찾고 싶습니다.

### 배열로 구현 시의 한계

만약 이러한 키-값 쌍 데이터를 가장 간단한 형태인 **배열**에 순차적으로 저장한다고 생각해 봅시다.

```
데이터 = [ (2621618951985135, 'Kim'), (3727238006122168, 'Park'), ... ]
```

이 경우, 새로운 데이터를 맨 뒤에 추가하는 append operation은 비교적 빠른 O(1)의 시간 복잡도를 가집니다. 하지만 특정 카드 번호를 찾아 해당 소유자의 이름을 알아내거나 특정 데이터를 삭제하려면 배열의 처음부터 끝까지 모든 요소를 하나씩 비교해야 합니다. 이는 데이터의 개수 N에 비례하는 **O(N)**의 시간 복잡도를 가지게 되어, 데이터 양이 많아질수록 성능이 크게 저하됩니다.

### 해시(Hash)가 필요한 경우: 빠른 탐색, 추가, 삭제의 요구

여기서 해시 자료구조의 진가가 발휘됩니다. 해시 테이블은 특정 키에 해당하는 값을 **평균적으로 O(1)**이라는 매우 빠른 시간 복잡도로 찾고, 추가하고, 삭제할 수 있도록 설계되었습니다.

어떤 문제나 상황에서 해시 테이블(파이썬에서는 `dict`로 구현) 사용을 고려해야 하는지는 다음과 같은 핵심적인 요구사항을 통해 파악할 수 있습니다. 핵심은 **"빠른 검색, 추가, 삭제가 중요할 때"** 입니다.

해시 테이블을 떠올릴 만한 대표적인 키워드 및 상황은 다음과 같습니다.

1.  **빠른 검색 및 존재 여부 확인:**
    - 어떤 특정 데이터(키)가 컬렉션 내에 **있는지 없는지를 빠르게** 확인해야 할 때.
    - 특정 키를 가지고 **관련된 정보(값)를 신속하게** 가져와야 할 때.
    - 관련 키워드: **검색, 찾기, 조회, 존재 확인, 등록 여부** 등.

2.  **중복 제거 및 유일한 요소 관리:**
    - 컬렉션에서 **중복된 값을 제거**하고 유일한 값만 남겨야 할 때 (이 경우 값 없이 키만 사용하는 해시 셋 형태를 응용).
    - 데이터 집합의 모든 요소가 **고유한지(unique)를 확인**해야 할 때.
    - 관련 키워드: **중복 제거, 유일한, 고유한** 등.

3.  **빈도수 계산:**
    - 각 요소가 데이터 내에서 **얼마나 자주 나타나는지**를 세고 싶을 때 (요소를 키로, 출현 횟수를 값으로 사용).
    - 관련 키워드: **빈도수, 개수 세기, 출현 횟수** 등.

4.  **키-값 매핑:**
    - 어떤 특정 값(키)에 다른 데이터(값)가 **1:1 또는 1:다 대응되는 관계**를 효율적으로 표현하고 관리하고 싶을 때 (예: 학생 ID와 성적 연결, 단어와 정의 연결).
    - 관련 키워드: **매핑, 연결, 대응, 쌍** 등.

5.  **잦고 빠른 추가/삭제 요구:**
    - 데이터가 컬렉션에 빈번하게 추가되거나 삭제되는데, 이러한 작업의 속도가 매우 중요할 때. 특히 특정 기준(키)으로 요소를 **빠르게 찾아서 삭제**해야 하는 경우 유용합니다.
    - 관련 키워드: **추가, 삽입, 삭제, 제거** (이 연산들이 빠른 성능으로 요구될 때).

6.  **데이터 순서가 중요하지 않을 때:**
    - 데이터가 저장되거나 검색되는 순서 자체가 핵심 요구사항이 아닐 때 해시 테이블이 적합합니다. (물론 파이썬 딕셔너리처럼 순서가 유지되거나, 다른 자료구조와 결합하여 순서를 관리할 수도 있습니다.)

**요약하자면:**

어떤 문제 해결에서 **특정 키를 기준으로 데이터를 빠르게 찾고, 추가하며, 삭제하는 작업의 효율성**이 매우 중요하고, 이러한 작업이 **대규모 데이터에 대해 평균적으로 상수 시간(O(1))** 안에 이루어져야 한다면, 해시 테이블은 가장 먼저 고려해야 할 강력한 도구입니다. 특히 "이미 있나요?", "~를 등록/저장하세요", "~를 명단에서 빼세요"와 같은 요구사항이 문제의 핵심이라면 딕셔너리(해시 테이블)가 최적의 해법일 가능성이 높습니다.

### Python에서의 해시 구현

Python 언어에서는 내장 자료구조인 **`dictionary`**가 해시 테이블로 구현되어 있습니다. 따라서 별도의 복잡한 해시 테이블 코드를 직접 구현할 필요 없이, `dict`를 가져다 사용함으로써 해시 자료구조의 이점을 누릴 수 있습니다.

```python
# Python 딕셔너리 (Hash Table) 사용 예시
card_holders = {
    "2621618951985135": "Kim",
    "3727238006122168": "Park",
    "8910282962811921": "Lee",
    "2077261047805305": "Ko"
}

# 빠른 검색 (O(1) 평균)
print(card_holders["8910282962811921"]) # 출력: Lee

# 존재 여부 확인 (O(1) 평균)
print("2621618951985135" in card_holders) # 출력: True
print("1234567890123456" in card_holders) # 출력: False

# 새로운 데이터 추가 (O(1) 평균)
card_holders["1111222233334444"] = "Choi"
print(card_holders)

# 데이터 삭제 (O(1) 평균)
del card_holders["2077261047805305"]
print(card_holders)
```

보시는 바와 같이 Python의 딕셔너리는 해시 테이블의 빠른 연산 특성을 그대로 제공하여 데이터 관리를 매우 효율적으로 수행할 수 있게 해줍니다.
