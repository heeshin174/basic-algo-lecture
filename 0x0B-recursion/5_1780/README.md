# [종이의 개수](https://www.acmicpc.net/problem/1780)

## 재귀를 이용한 풀이

n과 n-1의 관계를 알아야 한다. n이 총 9개의 정사각형으로 나누어진다.

### 구현

1. **함수의 정의**: 
	- `func(x, y, n)`: 시작점 (x, y)에 길이가 n인 n x n 배열이 같은 숫자를 포함하는 지 확인하는 함수
		- n = k에 대하여 n = k-1은 재귀가 9번 일어나야 합니다. n = k일 때와 n = k-1일 때 무엇이 바뀌는 지를 보면 어떤 parameter가 필요한 지 알 수 있습니다. 이전 호출과 달라진 점을 봅니다.
		- 한 변의 길이 n와 시작점 (x, y)이 재귀 시 마다 변합니다. 
2. **Base case**: 
    - `n == 1`이여서 더 이상 쪼개지지 않음
3. **재귀 호출(Recursive Call)**: 
	 - 길이를 3으로 나눠서 총 9번 재귀를 진행
	 - 시작점이 (0,0), (1/3, 0), (2/3, 0), (0, 1/3), (1/3,1/3), (2/3,1/3), (0, 2/3), (1/3, 2/3), (2/3, 2/3)가 된다.

### 시간복잡도:

한 재귀 당 총 9번의 재귀 호출이 일어나므로 시간 복잡도는 O(9ⁿ)입니다. 각 재귀 호출 당 요소들을 비교하기 위한 호출에서 9번의 비교가 일어나므로 O(9 * 9 * 9ⁿ)이 됩니다.

네, 재귀를 이용한 해당 문제 풀이의 시간 복잡도와 공간 복잡도 분석에 대해 검토해 보겠습니다.

제시하신 내용 중 일부는 맞지만, 시간 복잡도와 공간 복잡도를 도출하는 과정 및 최종 결론에 오류가 있습니다.

**1. 시간 복잡도 (Time Complexity)**

* **제시된 분석:** O(9^n) 또는 O(9 * 9 * 9ⁿ)
* **문제점:** 재귀 호출이 9번 일어나는 것은 맞지만, 각 재귀 호출에서 처리하는 문제의 크기가 줄어듭니다 (n -> n/3). 시간 복잡도는 재귀 구조와 각 단계에서 수행하는 작업량에 의해 결정됩니다. O(9^n) 형태의 복잡도는 문제가 독립적인 9개의 부분 문제로 나뉘면서도 문제 크기가 줄어들지 않거나, 줄어드는 비율이 상수가 아닐 때 나타나기 쉽습니다. 이 문제의 경우 문제 크기가 N/3으로 줄어듭니다.
* **정확한 분석:**
    * $T(n)$을 크기 $n \times n$ 문제를 해결하는 데 걸리는 시간이라고 합시다.
    * 함수 `func(x, y, n)` 내에서, 먼저 현재 $n \times n$ 영역이 모두 같은 숫자인지 확인해야 합니다. 이 과정은 모든 $n^2$개의 요소를 확인하므로 $O(n^2)$의 시간이 걸립니다.
    * 만약 영역이 모두 같은 숫자가 아니라면, 9개의 $(n/3) \times (n/3)$ 크기의 부분 문제로 나누어 재귀 호출합니다.
    * 따라서 시간 복잡도에 대한 점화식은 다음과 같습니다.
        $T(n) = 9 T(n/3) + O(n^2)$ (영역 확인 비용)
    * 이 점화식을 마스터 정리(Master Theorem)를 이용해 풀 수 있습니다. $a=9$, $b=3$, $f(n) = O(n^2)$ 입니다.
    * $n^{\log_b a} = n^{\log_3 9} = n^2$.
    * $f(n) = O(n^2)$ 이고 $n^{\log_b a} = n^2$ 이므로, $f(n)$은 $n^{\log_b a}$와 동일한 차수입니다. (마스터 정리 Case 2)
    * 따라서 시간 복잡도는 $T(n) = O(n^2 \log n)$ 입니다. 여기서 $\log n$은 재귀의 깊이(밑이 3인 로그)에서 나옵니다.

### 공간복잡도:

- 입력 공간: n×n 크기의 종이 정보를 저장하기 위해 O(n²)의 공간이 필요합니다.
- 보조 공간 (재귀 스택 공간): 재귀 호출이 일어날 때마다 함수 호출 정보(매개변수 x,y,n 등)가 스택에 쌓입니다. 재귀의 최대 깊이는 크기가 n에서 시작하여 n/3,n/9,…,1로 줄어드는 깊이이므로 $log_3n$에 비례합니다. 각 스택 프레임은 일정한 크기의 정보를 저장하므로, 재귀 스택이 사용하는 공간은 O(logn) 입니다.
- 총 공간: 입력 공간과 보조 공간을 합친 것입니다. 대부분의 경우 입력 공간은 제외하고 보조 공간만을 논하기도 하지만, 여기서는 입력 배열도 고려하는 것 같습니다.

> 총 공간 = 입력 공간 + 보조 공간 = O(n²)+O(logn)=O(n²).

O(n²)이라는 결론은 입력 배열을 포함한다면 맞을 수 있지만, 재귀 호출의 깊이는 O(logn) 이며, O(n²) 공간은 주로 입력 배열 저장에 필요한 공간입니다. 보조 공간만 고려하면 O(logn)입니다.