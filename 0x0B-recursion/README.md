# [재귀 (Recursion)](../workbook/0x0B.md)

재귀 함수는 함수가 자기 자신을 호출하는 함수를 의미합니다.

## 재귀함수의 공간 복잡도와 호출 스택

재귀 함수가 실행될 때마다, 해당 함수 호출을 위한 정보(지역 변수, 매개변수, 돌아갈 주소 등)가 **호출 스택(Call Stack)**이라는 메모리 공간에 쌓입니다. 재귀 호출이 깊어질수록 이 스택에 쌓이는 정보의 양이 많아집니다.

재귀 함수의 공간 복잡도는 이 **호출 스택의 최대 깊이**에 비례합니다.

```
def f(n):
    if (n == 1) return 1 # 기저 조건(Base Case)
    return f(n-1) + f(n-2)
```

`f(n-1)`와 `f(n-2)`처럼 두 번 재귀 호출하는 경우를 생각해 봅시다.

`f(n)`을 계산하기 위해 `f(n-1)`을 먼저 호출합니다. 그러면 호출 스택에는 `f(n)` 정보 위에 `f(n-1)` 정보가 쌓입니다. `f(n-1)`은 다시 `f(n-2)`를 호출하고... 이렇게 계속 내려가서 `f(1)`이나 `f(0)` 같은 **기저 조건(Base Case)**에 도달할 때까지 스택이 깊어집니다. 이 **가장 깊어지는 경로의 깊이가 최대 `n`**입니다 (예: `f(n) -> f(n-1) -> f(n-2) -> ... -> f(1)`). 이 경로의 깊이에 따라 스택 공간이 O(n)이 됩니다.

`f(n-1)` 계산이 끝나고 기저 조건으로부터 결과가 반환되기 시작하면, 스택에 쌓였던 `f(1)`, `f(2)`, ... `f(n-1)`의 정보들이 **차례대로 스택에서 제거(pop)**됩니다.

`f(n-1)` 계산이 완전히 끝난 후에야, 비로소 `f(n)`의 원래 호출 위치로 돌아와 `f(n-2)`를 호출하게 됩니다. `f(n-2)`가 호출되면 다시 스택에 `f(n-2)` 정보가 쌓이고, 이 호출 안에서 또 재귀가 진행됩니다.

핵심은 `f(n-1)`을 계산할 때 사용한 스택 공간과 `f(n-2)`를 계산할 때 사용한 스택 공간이 **동시에 최대치로 필요한 것이 아니라는 겁니다.** `f(n-1)` 계산이 끝나서 스택 공간을 비워준 후에 `f(n-2)` 계산을 위한 스택 공간을 사용하기 시작합니다.

따라서 전체 공간 복잡도는 `f(n-1)` 계산에 필요한 최대 스택 공간 (O(n))과 `f(n-2)` 계산에 필요한 최대 스택 공간 (O(n))을 더하는 것이 아니라, **두 호출 중 어느 하나를 실행할 때 필요한 '최대' 스택 공간**을 따르는 것입니다. 이 경우 최대 스택 깊이는 `n`에 비례하는 한 경로의 깊이가 됩니다.

**결론:**

- `f(n) = f(n-1) + f(n-2)` 형태의 순수 재귀 함수의 공간 복잡도는 **호출 스택의 최대 깊이에 의해 결정**되며, 이 최대 깊이는 `n`에 비례하여 **O(n)**입니다.
- 'O(n) + O(n)' 처럼 두 재귀 호출이 사용하는 공간을 단순히 더하는 방식은, 메모리가 순차적으로 사용되고 해제되는 호출 스택의 특성을 제대로 반영하지 못한 설명입니다. 공간 복잡도는 '최대 동시 사용 메모리' 개념입니다.

따라서 호출 스택이 n에 비례하기 때문에 O(n)이다. 재귀 호출의 최대 깊이가 n에 비례하여 O(n) 공간을 사용합니다.

## 시간 복잡도

**`f(n) = f(n-1) + f(n-2)` 형태의 재귀 함수**에 대한 **시간 복잡도**를 설명드릴게요.

- `f(n)`은 `f(n-1)`과 `f(n-2)`를 호출합니다.
- `f(n-1)`은 다시 `f(n-2)`와 `f(n-3)`을 호출하고...
- 이처럼 **같은 계산이 여러 번 중복**됩니다.

즉, 이 재귀 함수는 **이진 트리 형태의 호출 구조**를 가집니다.

```
                  f(5)
               /      \
           f(4)        f(3)
         /     \      /    \
     f(3)     f(2)  f(2)   f(1)
    /   \     / \   / \
f(2) f(1) f(1) f(0) ...
```

트리 형태의 전체 호출 횟수는 거의 `2^n`에 가까워집니다. 따라서 시간 복잡도는 O(2ⁿ)입니다.

**중복 호출 예**

예를 들어 `f(5)`를 계산할 때:

* `f(3)`이 여러 번 호출됩니다.
* `f(2)`는 네 번이나 호출됩니다.
* 이 중복을 줄이지 않으면 성능이 매우 비효율적입니다.


**결론**

| 항목         | 설명                  | 복잡도       |
| ---------- | ------------------- | --------- |
| **시간 복잡도** | 동일한 함수가 여러 번 중복 호출됨 | **O(2ⁿ)** |
| **공간 복잡도** | 호출 스택의 최대 깊이는 `n`   | **O(n)**  |

**최적화 방법**

이 문제는 **동일한 계산을 반복**하기 때문에 **메모이제이션(Memoization)** 또는 **DP (bottom-up)** 방식으로 해결하면 시간 복잡도를 \*\*O(n)\*\*으로 줄일 수 있습니다.