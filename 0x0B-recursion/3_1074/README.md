# [Z](https://www.acmicpc.net/problem/1074)

## 재귀를 이용한 풀이

재귀를 이용한 풀이를 사용할 때, n과 n-1번째 사이의 관계를 파악하는 것이 중요하다.

n번째 사각형을 총 4등분 한다.

1. 제1사분면: n-1번째
2. 제2사분면: n-1번째 + 제1사분면의 크기
3. 제3사분면: n-1번째 + 제1사분면의 크기 * 2
4. 제4사분면: n-1번째 + 제1사분면의 크기 * 3

이렇게 하면 n번째 사각형을 n-1번째 사각형으로 쪼개는 것이 가능하다.

### 구현

1. **함수의 정의**: 
	- `func(n, r, c)`: n번째 판 (2^n X 2^n) 배열에서 (r행, c열)을 몇 번째로 방문했는 지 계산하는  함수
2. **Base case**: 
	- n = 1일 때  r행 c열을 계산한다.
	- n = 0일 때 `return 0`
3. **재귀 호출(Recursive Call)**: 
	- n = k일 때 배열은 크게 네 구역으로 나눌 수 있습니다. 1구역은 `n = k-1`일 때의 결과를 그대로 사용하면 됩니다. 2구역은 1구역에서 얻는 결과에 1구역 만큼의 넓이만 더해주면 됩니다. 3구역은 2개의 사격형만큼, 4구역은 3개의 사각형만큼 더해주면 됩니다. 
	1. (r, c)가 1번 사각형일 때. `func(n-1,r,c);`
	2. (r, c)가 2번 사각형일 때. `half*half + func(n-1,r,c-half);`
	3. (r, c)가 3번 사각형일 때. `2*half*half + func(n-1,r-half,c);`
	4. (r, c)가 4번 사각형일 때. `3*half*half + func(n-1,r-half,c-half);`
	
	- 각 상황에 따른 반환 값은 위와 같습니다. 여기서 중요한 점은 하노이 문제와 다르게 이 문제는 상황에 따라 반환하는 값이 달라진다는 점 입니다. 위 경우를 쭉 실행하는 게 아니라 상황에 맞춰 적절한 것을 선택해야 합니다. 
	- half는 한 변 길이의 절반, 즉 `2^(n-1)`입니다. 이제 이것들을 합쳐서 구현을 하면 끝입니다.

### 시간복잡도: O(n)

재귀를 그래프로 생각하면 쉽게 시간복잡도를 파악할 수 있다.

(r,c)의 위치에 따라 네 가지 선택지 중 하나로 이동한다. 이를 총 n번 반복한다. 

```
시작
/ | | \
1 2 3 4
...
```

함수 `func(n, r, c)`는 매 호출마다 한 번의 비교와 산술연산만 하고, 다음 단계로 내려갈 때 `n`이 1씩 줄어듭니다. 따라서 총 호출 횟수는 n번, 전체 시간복잡도는 Θ(n)입니다.

### 공간복잡도: O(n)

재귀 함수의 공간복잡도는 call stack에 쌓이는 함수 호출만큼 공간을 차지한다. 함수가 n번 호출되면 (깊이가 n이면) call stack에 n만큼의 공간을 차지한다.