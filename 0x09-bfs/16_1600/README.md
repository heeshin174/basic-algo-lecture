# [말이 되고픈 원숭이](https://www.acmicpc.net/problem/1600)

원숭이와 말이 섞인 문제이다. 
- 말은 장애물을 건너뛸 수 있고, 원숭이는 장애물을 건너뛸 수 없다. 
- 말은 체스말처럼 움직이고, 원숭이는 상하좌우로 움직인다.
- 말은 최대 K번 사용할 수 있다. 원숭이의 움직임과 말의 움직임은 섞일 수 있다. 
- 시작은 (0,0)에서, 도착은 (n-1,m-1)에서 한다.

## BFS를 이용한 풀이

기본 BFS 알고리즘과 동일하게 작동하는데 다른 점이 있다. 말과 원숭이의 움직임에 순서가 없고 섞일 수 있기 때문에 따로 고려해야 한다.

한 지역에 도착하는 방법이 여러 방법이 있다. 이 지역까지 도착하는 방법은 최소일 수 있어도 도착점은 정해져 있기 때문에 다른 지역에 최소로 도착하는 방법은 중요하지 않고 도착점에 최소로 도착하는 방법이 제일 중요하다.

한 지역에 도착하는 데 필요한 말과 원숭이의 움직임의 횟수를 알아야 한다. 말 횟수만 제한이 있기 때문에 이것만 저장하면 된다.

`dist[horse_used][x][y]`에서 

1. `dist[1][3][4]`는 말을 사용한 횟수가 1이고 (0,0)에서 (3,4)로 이동하는 데 걸리는 최소 횟수이다.
2. `dist[2][3][4]`는 말을 사용한 횟수가 2이고 (0,0)에서 (3,4)로 이동하는 데 걸리는 최소 횟수이다.

이렇게 하면 말을 사용한 횟수를 최소로 하면서 도착점에 도착하는 최소 횟수를 구할 수 있다.

**방문 처리 및 최단 경로 갱신 조건 (가장 중요한 부분)**

- **현재 상태:** `(cur_x, cur_y)`에 `current_horse_used` 만큼의 말 이동을 사용하여 도달했으며, 이때까지의 총 이동 횟수는 `dist[current_horse_used][cur_x][cur_y]` 입니다.
- **이동:** `(cur_x, cur_y) -> (nx, ny)`로 이동할 때,

1. 원숭이 이동: (cur_x, cur_y)에서 horse_used를 그대로 사용하여 (nx, ny)로 이동. 
    - 이때, `dist[horse_used][nx][ny] == -1` (미방문)이어야 갱신한다.
    - 원숭이: `dist[horse_used][nx][ny] = dist[horse_used][cur_x][cur_y] + 1`
2. 말 이동: (cur_x, cur_y)에서 horse_used + 1를 사용하여 (nx, ny)로 이동 (단, horse_used < K 여야 함). 
    - 이때, `dist[horse_used + 1][nx][ny] == -1 (미방문) and horse_used + 1 <= K`이어야 갱신한다.
    - 말: `dist[horse_used+1][nx][ny] = dist[horse_used][cur_x][cur_y] + 1`

이 조건은 "이미 더 짧은 경로(또는 같은 횟수의 말 점프로 더 적은 총 이동)로 해당 상태 (특정 말 사용 횟수, x, y)에 도달한 경우 중복 탐색을 방지하고, 최단 경로임을 보장"합니다. BFS는 큐에 넣는 시점에 방문 처리를 하거나, 큐에서 꺼냈을 때 이미 처리된 최단 경로보다 길면 스킵하는 방식으로 구현합니다. dist 값을 비교하는 것이 그 역할을 합니다.