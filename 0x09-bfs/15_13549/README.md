# [숨바꼭질3](https://www.acmicpc.net/problem/13549)

## BFS를 이용한 풀이

수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

그래프로 나타내면 시작에서 총 3개의 갈림길이 있다.

```
              시작
/             |          \ 
x-1          x+1          2x
/ | \        / | \        / | \
x-1 x+1 2x x-1 x+1 2x x-1 x+1 2x
```

위 그래프를 BFS로 너비 탐색을 해 최솟값을 구한다.

그런데 이 문제는 2x로 가는데 시간이 안든다. 즉, 사실 선택지가 x-1, x+1 두 개가 있다.

```
    시작
/        \ 
x-1      x+1
/  \     / \
x-1 x+1 x-1 x+1
```

수빈이의 위치가 X일 때 이동 방법은 세 가지입니다.
- 걷기: 1초 후에 X-1 또는 X+1로 이동 (비용 1)
- 순간이동: 0초 후에 2*X의 위치로 이동 (비용 0)

이 문제는 각 간선(이동)에 가중치가 0 또는 1로 다르게 부여된 그래프에서 시작점부터 목표점까지의 최단 거리를 찾는 문제입니다. 표준 BFS는 모든 간선의 가중치가 같을 때 최단 거리를 보장하지만, 가중치가 다를 경우에는 최단 거리를 보장하지 못합니다.

가중치가 0과 1인 간선만 있는 경우, **Deque (양방향 큐)** 를 사용한 **0-1 BFS** 알고리즘을 통해 최단 거리를 효율적으로 찾을 수 있습니다. 이 방법은 0초가 걸리는 이동으로 도달한 노드는 큐의 앞에 넣어서 먼저 탐색하고, 1초가 걸리는 이동으로 도달한 노드는 큐의 뒤에 넣어서 나중에 탐색하는 방식입니다.

**0-1 BFS 풀이 단계:**

1.  **자료구조 초기화:**
    - `dist` 배열: 각 위치까지 도달하는 데 걸리는 최소 시간을 저장합니다. 문제의 최대 위치 (100,001) 크기로 선언하고, 충분히 큰 값(예: -1 또는 무한대)으로 초기화합니다.
    - `deque`: 탐색할 위치들을 저장하는 `collections.deque` 객체를 생성합니다.

2.  **시작 위치 설정:**
    - 시작 위치 `X`의 `dist[X]`를 0으로 설정합니다.
    - `deque`에 시작 위치 `X`를 삽입합니다. (덱의 앞이나 뒤 어디든 상관없습니다)

3.  **탐색 시작 (Deque가 빌 때까지):**
    - `deque`에서 **앞쪽**에 있는 위치 `curr`를 하나 꺼냅니다.
    - 만약 `curr`가 동생의 위치 `K`와 같다면, `dist[curr]`에 저장된 시간이 최소 시간이므로 탐색을 종료하고 해당 값을 출력합니다.
    - `curr`에서 이동할 수 있는 다음 위치들을 고려합니다.
        - **순간 이동 (`next = curr * 2`):**
            - 다음 위치 `next`가 유효한 범위(0부터 문제 최대 위치) 내에 있고, 현재까지 걸린 시간 (`dist[curr]`)이 `dist[next]`에 저장된 값보다 작거나 같을 경우 (더 짧거나 같은 경로를 찾은 경우):
                - `dist[next]`를 `dist[curr]`로 업데이트합니다. (0초 소요)
                - `next`를 `deque`의 **앞쪽**에 삽입합니다. (0초 이동은 우선 탐색)
        - **걷기 (`next = curr - 1`):**
            - 다음 위치 `next`가 유효한 범위 내에 있고, 현재까지 걸린 시간 + 1초 (`dist[curr] + 1`)가 `dist[next]`에 저장된 값보다 작을 경우 (더 짧은 경로를 찾은 경우):
                - `dist[next]`를 `dist[curr] + 1`로 업데이트합니다.
                - `next`를 `deque`의 **뒤쪽**에 삽입합니다. (1초 이동은 나중에 탐색)
        - **걷기 (`next = curr + 1`):**
            - 다음 위치 `next`가 유효한 범위 내에 있고, 현재까지 걸린 시간 + 1초 (`dist[curr] + 1`)가 `dist[next]`에 저장된 값보다 작을 경우:
                - `dist[next]`를 `dist[curr] + 1`로 업데이트합니다.
                - `next`를 `deque`의 **뒤쪽**에 삽입합니다.

4.  **결과 출력:** 동생 위치 `K`에 도달했을 때 저장된 `dist[K]` 값이 최소 시간입니다.
