# [1로 만들기 2](https://www.acmicpc.net/problem/12852)

1. X % 3 == 0
2. X % 2 == 0
3. X - 1

X가 1이 될 때까지 연산을 적용한다.

1 <= X <= 10^6 (1,000,000)

이 문제에서 포인트는 이전 선택을 전부 기억하고 있어야 한다는 점이다.

## DP를 이용한 풀이

`dp[i]`는 `i`를 1로 만들기 위한 최소 연산 횟수를 저장한다.

이 문제는 단순히 최소 연산 횟수만 구하는 것이 아니라, 어떤 과정을 거쳐야 최소 횟수로 1에 도달하는지 그 과정(경로)까지 출력해야 하는 문제입니다.

`dp[i]`만으로는 최소 횟수가 몇 번인지는 알 수 있지만, 어떤 연산(÷3, ÷2, -1)을 사용해서 그 횟수에 도달했는지는 알 수 없다. 바로 이 '어떤 연산을 사용했는지'를 기록하기 위해 `prev[i]` 배열이 필요합니다. `prev[i]`는 `i`라는 숫자를 1로 만들기 위한 최적의 경로에서, `i` 바로 이전에 어떤 숫자였는지를 기록하는 역할을 합니다.

- `prev[i]`는 `i`를 1로 만들기 위한 이전 선택을 저장한다.

예를 들어볼게요. 10이라는 숫자를 1로 만든다고 가정해 봅시다.

10에서 가능한 연산은 두 가지입니다.

1. 10을 2로 나누면 5가 됩니다.
2. 10에서 1을 빼면 9가 됩니다.

dp 계산 결과, 만약 5로 가는 경로가 9로 가는 경로보다 1에 도달하는 데 더 적은 연산이 필요하다고 결정되었다면 (`dp[5] < dp[9]`라면), dp[10]은 dp[5] + 1이 될 것입니다. 이 때, **'10은 5에서 오는 것이 최적의 경로다'**라는 정보를 `prev[10]`에 저장하는 것입니다. 예를 들어, `prev[10] = 5`라고 저장하는 식이죠.

이렇게 모든 숫자에 대해 `prev[i]`에 '바로 이전에 어떤 숫자에서 와야 최소 연산이 되는가'를 기록해두면, 나중에 시작 숫자 X부터 prev[X], prev[prev[X]], ... 이렇게 따라가면서 1까지의 경로를 역추적할 수 있습니다.

`dp[i] = min(dp[i], dp[i//2]+1)`로 구할 수 있다.

### 시간 복잡도: O(n)

- for 루프가 2부터 n까지 한 번 실행됩니다. 이 루프 안에서 각 숫자 i에 대해 최대 세 번의 비교 및 할당 연산이 이루어집니다 (i-1, i//2, i//3). 각 연산은 상수 시간(O(1))이 걸립니다.
- 따라서 for 루프 전체의 시간 복잡도는 n에 비례하게 되어 O(n)이 됩니다.
- 경로를 역추적하는 while 루프는 최악의 경우 (모든 연산이 -1인 경우) n번 반복됩니다. 하지만 이 부분은 전체 시간 복잡도 O(n)에 포함되므로, 알고리즘 전체의 시간 복잡도는 O(n)입니다.

### 공간 복잡도: O(n)

- dp 배열은 n+1 크기로 생성됩니다. 각 요소는 상수 크기의 정수를 저장합니다.
- prev 배열도 n+1 크기로 생성됩니다. 각 요소는 상수 크기의 정수(이전 숫자의 인덱스)를 저장합니다.
- path 리스트는 최악의 경우 (모든 연산이 -1인 경우) n개의 숫자를 저장하게 됩니다.

세 배열/리스트 모두 n에 비례하는 공간을 사용하며, 상수 계수는 무시하므로 전체 공간 복잡도는 O(n)입니다.