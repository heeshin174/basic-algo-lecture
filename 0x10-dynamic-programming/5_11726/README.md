# [2×n 타일링](https://www.acmicpc.net/problem/11726)

2×n 직사각형을 1×2 또는 2×1 크기의 타일로 꽉 채우는 방법이 몇 가지나 되는지 세는 문제입니다.

예를 들어 2×2 크기의 직사각형이 있다면, 다음과 같이 딱 두 가지 방법으로 채울 수 있습니다.

1.  가로 타일 두 개를 위아래로 놓기:
    ```
    ==
    ==
    ```
2.  세로 타일 두 개를 나란히 놓기:
    ```
    | |
    | |
    ```

입력으로 직사각형의 긴 변의 길이 `n`이 주어지면, 2×`n` 크기의 직사각형을 채우는 모든 방법의 수를 구해서 출력하면 됩니다. 단, 답이 너무 커질 수 있으니 10,007로 나눈 나머지를 출력해야 해요.

- 예제 입력 1에서 `n`이 2일 때, 우리가 위에서 확인한 것처럼 답은 2가 됩니다.
- 예제 입력 2에서 `n`이 9라면, 채우는 방법의 수가 훨씬 많아지고, 그걸 계산해서 10,007로 나눈 나머지가 55라는 의미입니다.

## DP를 이용한 풀이

n을 구할 때, 이전의 결과를 이용할 수 있습니다. 어떤 방식으로 이용할 수 있는 지를 생각해야 합니다.

2×`n` 직사각형을 채우는 방법의 수를 구할 때, 2×(`n`-1) 또는 그보다 작은 크기의 직사각형을 채우는 방법의 수와 어떤 관계가 있을까요? 2×`n` 직사각형의 가장 오른쪽 열을 어떻게 채울 수 있을지 생각해 봅시다. 가능한 경우는 크게 두 가지가 있습니다.

1.  **가장 오른쪽에 2×1 타일 하나를 놓는 경우:**

    만약 가장 오른쪽에 세로로 긴 2×1 타일을 놓는다면, 그 왼쪽에는 2×(`n`-1) 크기의 직사각형이 남게 됩니다. 따라서 2×(`n`-1) 크기의 직사각형을 채우는 방법의 수만큼, 현재 경우를 만들 수 있습니다.

    ```
    ... |
    ... |
    ```

2.  **가장 오른쪽에 1×2 타일 두 개를 가로로 놓는 경우:**

    만약 가장 오른쪽에 가로로 긴 1×2 타일 두 개를 위아래로 놓는다면, 그 왼쪽에는 2×(`n`-2) 크기의 직사각형이 남게 됩니다. 따라서 2×(`n`-2) 크기의 직사각형을 채우는 방법의 수만큼, 현재 경우를 만들 수 있습니다.

    ```
    ... ==
    ... ==
    ```

이 두 가지 경우는 서로 겹치지 않는 모든 가능한 마지막 열의 형태를 나타냅니다. 따라서 2×`n` 직사각형을 채우는 방법의 수는 2×(`n`-1) 직사각형을 채우는 방법의 수와 2×(`n`-2) 직사각형을 채우는 방법의 수를 더한 것과 같습니다.

이를 점화식으로 표현하면 다음과 같습니다.

Let $dp[i]$ be the number of ways to tile a 2×$i$ rectangle.
Then, $dp[n] = dp[n-1] + dp[n-2]$ for $n \ge 2$.

이제 초기 조건이 필요합니다.

* $n = 1$일 경우, 2×1 직사각형은 2×1 타일 하나로 채우는 한 가지 방법밖에 없습니다. 따라서 $dp[1] = 1$.
* $n = 2$일 경우, 2×2 직사각형은 우리가 앞에서 확인했듯이 두 가지 방법으로 채울 수 있습니다. 따라서 $dp[2] = 2$.

이제 $n \ge 3$인 경우부터는 위의 점화식을 이용해서 $dp[n]$ 값을 순차적으로 계산해 나갈 수 있습니다. 최종적으로 우리가 원하는 답은 $dp[n]$이 될 것이고, 문제 조건에 따라 10,007로 나눈 나머지를 출력해야 합니다.

### 시간 복잡도: O(n)

for 루프를 사용하여 n번 반복적인 계산을 수행합니다. 루프 내부에서는 덧셈과 나머지 연산만이 이루어지는데, 이들은 모두 상수 시간, 즉 O(1)의 시간 복잡도를 가집니다. 따라서, 전체적으로 이 DP 알고리즘의 시간 복잡도는 입력 크기 n에 선형적으로 비례하는 **O(n)**이 됩니다. 이는 n이 커질수록 계산 시간이 그에 비례하여 증가한다는 것을 의미하며, 효율적인 풀이라고 할 수 있습니다.

### 공간 복잡도: O(n)

이전 계산 결과를 저장하기 위해 dp라는 배열을 사용했습니다. 이 배열의 크기는 n+1입니다. 따라서, 입력 크기 n에 따라 선형적으로 메모리 공간을 사용하게 됩니다. 그러므로, 이 DP 알고리즘의 공간 복잡도는 **O(n)**입니다. n이 커질수록 저장해야 하는 값의 개수도 비례하여 증가합니다.
