# [Dynamic Programming (DP)](../workbook/0x10.md)

동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 작은 하위 문제(subproblem)들로 나누어 풀고, 이 하위 문제들의 해결 결과를 저장해 두었다가 같은 하위 문제가 다시 나타날 때 저장된 결과를 재활용하여 전체 문제의 해결 속도를 비약적으로 높이는 알고리즘 설계 기법입니다.

쉽게 말해, **"한 번 계산했던 것은 다시 계산하지 않고 기록해 두자!"**는 전략입니다.

주요 아이디어는 두 가지입니다.

1.  **작은 문제로 쪼개기 (Optimal Substructure):** 큰 문제의 최적 해가 그 문제를 구성하는 작은 문제들의 최적 해로부터 얻어질 수 있어야 합니다. (예: A에서 C까지 가는 최단 경로는, A에서 B까지 가는 최단 경로와 B에서 C까지 가는 최단 경로로 이루어진다.)
2.  **겹치는 하위 문제 (Overlapping Subproblems):** 문제를 재귀적으로 풀 때, 동일한 작은 문제가 여러 번 반복해서 계산되는 구조여야 합니다. 동적 계획법은 바로 이 겹치는 문제를 한 번만 계산하고 결과를 저장해서 효율성을 얻습니다. (예: 피보나치 수열 계산 - `fib(5)`를 계산하려면 `fib(4)`와 `fib(3)`이 필요하고, `fib(4)`를 계산하려면 `fib(3)`과 `fib(2)`가 필요하므로 `fib(3)`이 두 번 필요해집니다.)

**어떻게 구현하나요? 두 가지 주요 방식이 있습니다.**

1.  **하향식 (Top-Down, 메모이제이션 - Memoization):**
    - 가장 큰 문제부터 시작하여 재귀적으로 하위 문제를 호출하며 내려갑니다.
    - 하위 문제를 처음 계산할 때 그 결과를 저장(메모)해 둡니다.
    - 같은 하위 문제가 다시 호출되면, 계산하는 대신 저장된 결과를 즉시 반환합니다.
    - 마치 똑똑한 학생이 한 번 푼 문제는 해답을 적어두고 다음에 나오면 해답을 보는 것과 같습니다.

2.  **상향식 (Bottom-Up, 타뷸레이션 - Tabulation):**
    - 가장 작은 하위 문제부터 시작하여 순서대로 해결하고 그 결과를 테이블(보통 배열이나 리스트)에 저장합니다.
    - 점점 더 큰 하위 문제를 해결해 나가면서 테이블에 저장된 더 작은 문제들의 결과를 이용합니다.
    - 최종적으로 가장 큰 문제(원래 우리가 풀고 싶었던 문제)의 해결 결과를 얻습니다.
    - 마치 빌딩을 지을 때 1층부터 차근차근 쌓아 올려서 결국 꼭대기층을 완성하는 것과 같습니다.

**왜 사용하나요?**

- **압도적인 효율성:** 겹치는 하위 문제가 많은 문제의 경우, 동적 계획법을 사용하면 계산 횟수를 크게 줄여 보통 지수 시간 복잡도(Exponential time complexity) 문제를 다항 시간 복잡도(Polynomial time complexity) 문제로 개선할 수 있습니다.

**대표적인 동적 계획법 문제 예시:**

- 피보나치 수열 계산
- 배낭 문제 (Knapsack Problem)
- 최장 공통 부분 수열 (Longest Common Subsequence)
- 행렬 곱셈 순서 (Matrix Chain Multiplication)
- 그리고 이전 질문에서 다룬 **"1, 2, 3 더하기" 문제**도 대표적인 DP 문제입니다. (dp[i] = dp[i-1] + dp[i-2] + dp[i-3] 점화식 사용)

요약하자면, 동적 계획법은 문제를 쪼개고 겹치는 부분을 한 번만 계산해서 효율적으로 문제를 해결하는 방법입니다. 특히 재귀적으로 표현될 수 있고 겹치는 하위 문제가 많이 발생하는 문제에 강력합니다.