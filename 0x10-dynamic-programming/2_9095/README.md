# [1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

## 직관적인 풀이 (사용X)

처음엔 전부 1을 더하는 것으로 시작한다. 

1. [1,2,3] 조합이 가질 수 있는 총 조합을 계산한다.
    - n = 4
    - [1: 4, 2: 0, 3: 0]은 4개의 1을 가진 조합을 의미한다. (1,1,1,1)
    - [1: 3, 2: 1, 3: 0]은 3개의 1, 1개의 2를 가진 조합을 의미한다. (1,1,1,2)
    - [1: 2, 2: 2, 3: 0]은 2개의 1, 2개의 2를 가진 조합을 의미한다. (1,1,2,2)
2. 각 조합 당 위치를 변경하는 경우의 수를 계산한다.
    - [1: 3, 2: 1, 3: 0]에서 2의 위치를 변경하여 총 4개의 경우의 수가 된다. 
    - (1,1,1,2), (1,1,2,1), (1,2,1,1), (2,1,1,1)

이 방식의 장점:

- 수학적으로 직관적이며, 경우의 수 개념을 그대로 적용한 것입니다.

이 방식의 어려움 (구현 관점에서):

- 가능한 모든 조합 찾기: `c1*1 + c2*2 + c3*3 = n` 을 만족하는 음이 아닌 정수 c1, c2, c3의 모든 쌍을 체계적으로 찾는 과정이 필요합니다. 이는 보통 반복문을 통해 구현해야 하는데, 예를 들어 c3를 0부터 n/3까지, c2를 0부터 (n - 3*c3) / 2까지 반복하면서 c1을 계산하는 방식이 될 수 있습니다. 이 과정 자체가 n이 커지면 복잡해지고 계산량이 늘어납니다.
- 순열 계산 (다항 계수 계산): `(c1 + c2 + c3)! / (c1! * c2! * c3!)` 형태의 계산이 필요합니다. 문제는 n이 커지면 `(c1 + c2 + c3)!` 값이 매우 빠르게 커져서 일반적인 정수 자료형으로는 표현할 수 없게 오버플로우가 발생할 수 있습니다. 물론 분자와 분모를 적절히 나눠가며 계산하거나, 로그를 이용하는 등 오버플로우를 피하는 방법도 있지만, 구현이 훨씬 복잡해집니다.

따라서, 생각하신 방식은 이론적으로 맞지만, 컴퓨터 프로그램으로 구현하기에는 효율성이나 오버플로우 문제 때문에 다소 까다로울 수 있습니다.

## Dynamic Programming, DP를 이용한 풀이

`dp[i]` 라는 것을 만들어서 **"숫자 i를 1, 2, 3의 합으로 나타내는 경우의 수"** 라고 정의하는 거예요.

우리는 `dp[1]`, `dp[2]`, `dp[3]`부터 시작해서 차례대로 `dp[4]`, `dp[5]`, ... 쭉 계산해서 마지막에 `dp[n]`을 찾는 거죠.

자, `dp[i]` (숫자 i를 만드는 방법의 총 가짓수)를 어떻게 계산할까요?

어떤 합이 숫자 `i`가 되려면, 그 합의 **마지막에 더해지는 숫자는 반드시 1 또는 2 또는 3 중 하나**일 거예요. 다른 숫자는 사용할 수 없으니까요.

그러니까, `i`를 만드는 전체 방법은 다음 세 가지 경우를 합친 것과 같습니다.

1.  **맨 마지막에 1을 더해서 `i`가 되는 경우:**
    - 맨 마지막에 1을 더했다면, 1을 더하기 전까지의 합은 `i - 1`이 되었을 거예요.
    - 그렇다면 `i - 1`을 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '1'만 붙이면, `i`를 만들고 마지막이 1인 경우가 되는 거죠.
    - `i - 1`을 만드는 방법의 수는 우리가 이미 앞에서 계산해 놓은 `dp[i - 1]` 입니다.
    - **따라서, 마지막이 1인 경우의 수는 `dp[i - 1]`과 같습니다.**

2.  **맨 마지막에 2를 더해서 `i`가 되는 경우:**
    * 맨 마지막에 2를 더했다면, 2를 더하기 전까지의 합은 `i - 2`가 되었을 거예요.
    - `i - 2`를 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '2'만 붙이면, `i`를 만들고 마지막이 2인 경우가 됩니다.
    - `i - 2`를 만드는 방법의 수는 `dp[i - 2]` 입니다.
    - **따라서, 마지막이 2인 경우의 수는 `dp[i - 2]`와 같습니다.**

3.  **맨 마지막에 3을 더해서 `i`가 되는 경우:**
    - 맨 마지막에 3을 더했다면, 3을 더하기 전까지의 합은 `i - 3`이 되었을 거예요.
    - `i - 3`을 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '3'만 붙이면, `i`를 만들고 마지막이 3인 경우가 됩니다.
    - `i - 3`을 만드는 방법의 수는 `dp[i - 3]` 입니다.
    - **따라서, 마지막이 3인 경우의 수는 `dp[i - 3]`과 같습니다.**

이 세 가지 경우는 겹치지 않으면서 `i`를 만드는 모든 방법을 다 포함합니다. (어떤 합이든 맨 마지막 숫자는 1, 2, 3 중 하나여야 하므로)

그래서, `i`를 만드는 전체 방법의 수 `dp[i]`는 이 세 가지 경우의 수를 모두 더한 것과 같습니다.

**`dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]`**

이게 바로 이 문제의 동적 계획법 **점화식**입니다.

**계산은 이렇게 진행됩니다:**

먼저 아주 작은 값들의 `dp` 값을 우리가 직접 세서 정해둡니다. 이걸 **기저 조건 (Base Case)**이라고 해요.

- `dp[0]`: 0을 만드는 방법? 아무것도 더하지 않는 1가지 방법이 있다고 약속합니다. (나중에 계산을 위해 필요해요). `dp[0] = 1`
- `dp[1]` : 1을 만드는 방법? `1` 하나. -> 1가지. `dp[1] = 1`
- `dp[2]` : 2를 만드는 방법? `1+1`, `2`. -> 2가지. `dp[2] = 2`
- `dp[3]` : 3을 만드는 방법? `1+1+1`, `1+2`, `2+1`, `3`. -> 4가지. `dp[3] = 4`

이제 점화식을 사용해서 차례대로 계산합니다.

- `dp[4]` = `dp[3] + dp[2] + dp[1]` = 4 + 2 + 1 = 7
    - (4를 만드는 방법은 3 만드는 방법 뒤에 1 붙이기 + 2 만드는 방법 뒤에 2 붙이기 + 1 만드는 방법 뒤에 3 붙이기)
- `dp[5]` = `dp[4] + dp[3] + dp[2]` = 7 + 4 + 2 = 13
- `dp[6]` = `dp[5] + dp[4] + dp[3]` = 13 + 7 + 4 = 24
    ... 이런 식으로 `dp[n]`까지 계산하면 됩니다.

단순히 바로 직전(i-1), 두 칸 앞(i-2), 세 칸 앞(i-3)에서 계산해 둔 값을 더하기만 하면 `dp[i]`가 바로 나옵니다. 계산 과정이 덧셈만 사용하므로 오버플로우 걱정도 훨씬 적고, 구현도 배열(list) 하나 만들고 반복문 돌면서 점화식 적용하는 식으로 아주 간단해집니다.

### 시간 복잡도 (Time Complexity)

`dp[i]` 값을 `i = 4`부터 시작해서 목표 값인 `n`까지 순차적으로 계산합니다. 각 `dp[i]`를 계산할 때, `dp[i-1]`, `dp[i-2]`, `dp[i-3]` 값을 가져와서 단순히 두 번의 덧셈만 수행합니다. 이 덧셈 연산과 이전 값을 가져오는 작업은 **상수 시간(O(1))**이 걸립니다.

우리는 이 상수 시간 연산을 `i`가 4일 때, 5일 때, ..., `n`일 때까지, 총 `n`에 비례하는 횟수만큼 반복합니다 (정확히는 `n-3`번). 따라서 전체 계산에 걸리는 시간은 `n`에 선형적으로 비례합니다.

결론적으로, 이 동적 계획법 풀이의 시간 복잡도는 **O(n)** 입니다. 입력 `n`이 두 배가 되면, 계산 시간도 대략 두 배가 됩니다.

### 공간 복잡도 (Space Complexity)

공간 복잡도는 입력값 `n`이 커짐에 따라 알고리즘이 사용하는 메모리 공간이 얼마나 증가하는지를 나타냅니다.

이전에 계산된 `dp[i]` 값들을 저장하기 위해 배열 자료구조를 사용합니다. `dp[0]` 또는 `dp[1]`부터 시작해서 `dp[n]`까지의 값을 저장하려면, 최소한 `n`개의 숫자를 저장할 공간이 필요합니다. 예를 들어 `dp[0]`부터 `dp[n]`까지 모두 저장한다면 `n+1`개의 공간이 필요하겠죠.

사용하는 메모리 공간의 양이 입력 `n`의 크기에 선형적으로 비례합니다. 따라서, 이 동적 계획법 풀이의 공간 복잡도는 **O(n)** 입니다. 입력 `n`이 두 배가 되면, 사용하는 메모리 공간도 대략 두 배가 됩니다.

참고로, `dp[i]` 값을 계산할 때 필요한 것은 바로 직전 세 개의 값(`dp[i-1]`, `dp[i-2]`, `dp[i-3]`) 뿐입니다. 이 점을 이용하면 굳이 `dp[0]`부터 `dp[n]`까지 모든 값을 저장할 필요 없이, 현재 계산에 필요한 이전 세 개의 값만 변수 몇 개에 저장하면서 계산을 진행할 수 있습니다. 이렇게 구현하면 사용하는 메모리 공간을 상수로 만들 수 있어, 공간 복잡도를 **O(1)**으로 최적화하는 것도 가능합니다.