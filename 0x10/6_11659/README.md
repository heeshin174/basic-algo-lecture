# [구간 합 구하기 4](https://www.acmicpc.net/problem/11659)

맨 처음 생각할 수 있는 풀이는 배열에 모든 숫자를 집어넣고 주어진 구간에 대한 합을 직접 구하는 것입니다. 

하지만 우리는 한 번만 계산할 것이 아니라 최대 10만회의 계산을 할 것이기 때문에 이 풀이는 시간초과를 일으킬 것입니다.

그렇다면 어떻게 해야 할까요?

## prefix sum (구간 합) + DP를 이용한 풀이

구간 합이란 배열의 **0번째 인덱스부터 특정 인덱스까지의 원소들의 합**을 의미합니다. 이를 활용하면 주어진 구간의 합을 효율적으로 계산할 수 있습니다.

**DP (Dynamic Programming)를 이용한 구간 합 배열 만들기**

1.  **구간 합 배열 초기화:** 원래 배열과 크기가 같은 새로운 배열 (예를 들어, `prefix_sum`)을 만들고, 첫 번째 원소 `prefix_sum[0]`은 원래 배열의 첫 번째 원소와 동일하게 설정합니다.

2.  **구간 합 계산:** 원래 배열의 두 번째 원소부터 마지막 원소까지 순회하면서, 현재 위치의 구간 합은 **이전 위치의 구간 합**과 **현재 위치의 원래 배열 값**을 더하여 계산합니다. 즉, 다음과 같은 점화식을 사용할 수 있습니다.

    ```
    prefix_sum[i] = prefix_sum[i-1] + original_array[i]  (for i > 0)
    ```

**구간 합을 이용한 특정 구간의 합 계산**

만약 우리가 원래 배열의 `i`번째 인덱스부터 `j`번째 인덱스까지의 합 (단, $i \le j$)을 구하고 싶다면, 미리 계산해 둔 구간 합 배열을 이용하여 다음과 같이 간단하게 계산할 수 있습니다.

```
구간 [i, j]의 합 = prefix_sum[j] - prefix_sum[i-1]
```

**예시**

원래 배열이 `[1, 2, 3, 4, 5]`라고 할 때, 구간 합 배열은 다음과 같이 계산됩니다.

- `prefix_sum[0] = 1`
- `prefix_sum[1] = prefix_sum[0] + 2 = 1 + 2 = 3`
- `prefix_sum[2] = prefix_sum[1] + 3 = 3 + 3 = 6`
- `prefix_sum[3] = prefix_sum[2] + 4 = 6 + 4 = 10`
- `prefix_sum[4] = prefix_sum[3] + 5 = 10 + 5 = 15`

따라서 구간 합 배열은 `[1, 3, 6, 10, 15]`가 됩니다.

이제 원래 배열의 2번째 인덱스부터 4번째 인덱스까지의 합 (즉, 3 + 4 + 5)을 구하려면, 구간 합 배열을 이용하여 다음과 같이 계산합니다.

```
구간 [2, 4]의 합 = prefix_sum[4] - prefix_sum[2-1] = prefix_sum[4] - prefix_sum[1] = 15 - 3 = 12
```

**장점**

이러한 구간 합과 DP를 이용한 풀이 방식은 다음과 같은 장점을 가집니다.

- **효율적인 구간 합 계산:** 한 번의 전처리 (구간 합 배열 생성)를 통해 이후의 모든 구간 합 계산을 상수 시간 O(1)으로 수행할 수 있습니다.
- **반복적인 계산 방지:** 동일한 구간에 대한 합을 여러 번 계산할 필요가 없어 시간 복잡도를 크게 줄일 수 있습니다.

### 시간 복잡도: O(n)

구간 합 배열 prefix_sum을 만드는 과정에서 배열 nums를 한 번 순회하는 for 루프가 사용되기 때문입니다. 이후 각 질의에 대한 구간 합 계산은 배열의 특정 인덱스 값에 접근하는 것이므로 상수 시간 O(1)이 걸립니다. 따라서 총 시간 복잡도는 초기 구간 합 배열 생성에 걸리는 시간인 O(n)이 됩니다.

### 공간 복잡도: O(n)

prefix_sum 배열의 크기가 입력 배열 nums의 크기에 비례하는 n+1이기 때문입니다. 입력 배열 자체를 저장하는 공간도 O(n)이므로, 총 공간 복잡도는 O(n)+O(n)=O(n)으로 표현됩니다.