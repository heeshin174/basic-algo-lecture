# [RGB거리](https://www.acmicpc.net/problem/1149)

집이 N개. 각 집은 R, G, B 중 하나의 색깔로 칠해진다.
모든 집을 칠하는 최소 비용 구하기.

## 백트래킹 + 가지치기 풀이

```
          시작
    /       |     \
1   R       G      B
   /  \   /  \    /  \
2  G   B  R   B   R  G
  / \ / \ / \ / \ / \ / \
3 R B R G B G R G G B B R
...
```

최소 비용을 구하기 위해서는 모든 길을 전부 탐색해야 한다. 이는 BFS보단 DFS에 어울린다. 

현재까지의 탐색한 길의 최소값을 저장한 후 특정 지점에서 이전 최소값보다 커지면 탐색을 중단하는 방식으로 최적화할 수 있다. 이는 백트레킹으로 해결할 수 있다.


현재 풀이:
- 모든 가능한 색 조합을 재귀적으로 탐색한다.
- **이미 최소값보다 커지면 중단(가지치기)**한다.
- 일종의 완전 탐색 + 최적화예요.

문제점:
- 시간 복잡도가 최악의 경우 2ⁿ ~ 3ⁿ에 가까워요.
- 집이 1000개까지 있을 수 있어서 시간 초과 발생합니다.
- 백트래킹은 경우의 수가 적은 문제에 적합해요 (예: N ≤ 20)

### 시간복잡도: O(2^n)

시간 복잡도는 입력값인 집의 개수 n이 커짐에 따라 코드의 실행 시간이 얼마나 증가하는지를 나타냅니다.

백트래킹 함수 `backtrack()`는 각 집(house)에 대해 색깔을 결정하며 재귀적으로 호출됩니다.

- 첫 번째 집(house = 0)의 경우, 3가지 색상 (빨강, 초록, 파랑) 중 하나를 선택할 수 있습니다.
- 두 번째 집(house = 1)부터는 바로 이전 집과 같은 색은 선택할 수 없습니다. 따라서 이전 집 색깔을 제외한 2가지 색상 중에서 선택하게 됩니다.
- 세 번째 집, 네 번째 집... n번째 집까지 모두 이전 집 색깔을 제외한 2가지 색상 중에서 선택하게 됩니다.

가지치기(Pruning, `if current_cost >= min_cost: return`) 부분이 없다면, 이론적으로 탐색하게 되는 모든 가능한 색칠 경우의 수는 첫 집의 3가지 선택에 이어지는 각 집의 2가지 선택들의 곱이 됩니다. 즉, 3 * 2 * 2 * ... * 2 (n-1번) = 3 * 2^(n-1) 가지의 경로를 탐색하게 됩니다.

따라서 가지치기가 없는 순수한 백트래킹의 경우, 시간 복잡도는 **O(2^n)**이 됩니다. 이는 n이 조금만 커져도 실행 시간이 기하급수적으로 늘어나는 매우 비효율적인 시간 복잡도입니다.

하지만 코드에 있는 `if current_cost >= min_cost: return`과 같은 가지치기가 있기 때문에, 탐색 도중에 현재까지의 비용이 이미 찾은 최소 비용보다 커지면 해당 경로는 더 이상 탐색하지 않고 중단합니다. 이 가지치기 덕분에 실제 실행 시간은 최악의 경우인 O(2^n)보다는 훨씬 빠를 수 있습니다. 하지만 이론적인 최악의 시간 복잡도는 여전히 탐색 공간의 구조에 따라 O(2^n)에 가깝다고 볼 수 있습니다.

결론적으로, 이 백트래킹 코드의 이론적 최악 시간 복잡도는 가지치기 효과를 고려하지 않으면 O(2^n) 이고, 가지치기로 인해 실제 성능은 입력 데이터에 따라 그보다 훨씬 좋을 수 있습니다.

### 공간복잡도: O(n)

재귀 함수 `backtrack`를 사용합니다. 재귀 함수가 호출될 때마다 해당 함수의 실행 정보가 스택 (call stack)에 쌓이게 됩니다. 이 스택의 최대 깊이가 공간 복잡도에 큰 영향을 미칩니다.

함수 `backtrack(house, ...)`는 house 값을 0부터 시작하여 1씩 증가시키며 재귀 호출됩니다. 재귀 호출은 house가 n이 될 때까지 이어지므로, 재귀 호출의 최대 깊이는 n이 됩니다.

따라서 재귀 호출 스택이 사용하는 공간은 최대 깊이 n에 비례합니다. 또한, 입력으로 주어지는 비용 정보 cost 매트릭스도 n x 3 크기이므로 **O(n)**의 공간을 사용합니다.

재귀 스택의 공간과 입력 cost 매트릭스의 공간 모두 n에 비례하므로, 이 코드의 전체 공간 복잡도는 O(n) 입니다. 입력 n이 두 배가 되면, 사용하는 메모리 공간도 대략 두 배가 됩니다.

## DP를 이용한 풀이

DP를 이용한 풀이는 백트래킹보다 훨씬 효율적입니다.

이 문제는 **작은 문제를 이용해서 큰 문제를 해결**할 수 있는 **전형적인 DP 문제**예요.

아이디어:
- `dp[i][0]` = i번째 집을 빨강으로 칠했을 때의 최소 비용
- `dp[i][1]` = 초록
- `dp[i][2]` = 파랑

이전 집과 **다른 색**으로만 칠할 수 있으므로 다음과 같이 점화식이 세워져요:

```python
dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]
dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1]
dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2]
```

초기값은 그냥 그대로:

```python
dp[1][0] = cost[1][0]
dp[1][1] = cost[1][1]
dp[1][2] = cost[1][2]
```

### 시간 복잡도: O(N)

- 한 줄씩 처리하면 되기 때문에 훨씬 빠릅니다.
- 3가지 색 \* N개의 집 = 3N ≈ O(N)
