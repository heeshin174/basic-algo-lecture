from collections import deque

n = int(input())

q = deque()
q.append((n, 0))

while q:
    cur, cnt = q.popleft()
    if cur == 1:
        print(cnt)
        break
    if cur % 3 == 0:
        q.append((cur // 3, cnt + 1))
    if cur % 2 == 0:
        q.append((cur // 2, cnt + 1))
    q.append((cur - 1, cnt + 1))


'''
BFS를 이용한 풀이

시간복잡도: O(3^N) - 최악의 경우 갈림길이 세 개인 나무를 높이 N만큼 끝까지 타고 내려가는 셈이에요.
공간복잡도: O(3^N) - 큐에 최대 3^N개의 원소가 저장될 수 있음

일단 이 탐색은 `-1`, `÷2`, `÷3` 이렇게 세 가지 선택지를 매번 시도한다. 갈림길이 세 개인 나무를 높이 N만큼 끝까지 타고 내려가는 셈이에요.

- **갈림길(branching)이 3개**: 각 숫자마다 최대 세 방향으로 새 자식이 생기고,
- **높이가 N**: 제일 길게는 10에서 1까지 `-1`만 쓰면 N단계니까요.

완전한 3-진 트리(full 3‑ary tree)의 노드 수가 대략 $1 + 3 + 3^2 + \dots + 3^N$이 되듯, **총 시도 횟수**가 $O(3^N)$에 수렴합니다.

그리고 BFS는 너비 우선이니 가장 넓은 레벨의 모든 노드를 큐에 담고 있어야 하죠. 완전 3-진 트리의 한 레벨 크기가 $3^d$라서, 최악에는 $d=N$일 때 $3^N$개를 메모리에 올려놓습니다. 
그래서 공간도 $O(3^N)$이 되는 거고요.

한 문장으로 요약하면,

> 방문 체크 없이 매번 세 갈림길을 다 타고 내려가면, 트리 모양이 분기 계수 3, 깊이 N인 지수 구조가 되어 시간·공간 모두 $O(3^N)$이 됩니다.
'''

