# [1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

## 직관적인 풀이 (사용X)

처음엔 전부 1을 더하는 것으로 시작한다. 

1. [1,2,3] 조합이 가질 수 있는 총 조합을 계산한다.
  - n = 4
  - [1: 4, 2: 0, 3: 0]은 4개의 1을 가진 조합을 의미한다. (1,1,1,1)
  - [1: 3, 2: 1, 3: 0]은 3개의 1, 1개의 2를 가진 조합을 의미한다. (1,1,1,2)
  - [1: 2, 2: 2, 3: 0]은 2개의 1, 2개의 2를 가진 조합을 의미한다. (1,1,2,2)
2. 각 조합 당 위치를 변경하는 경우의 수를 계산한다.
  - [1: 3, 2: 1, 3: 0]에서 2의 위치를 변경하여 총 4개의 경우의 수가 된다. 
  - (1,1,1,2), (1,1,2,1), (1,2,1,1), (2,1,1,1)

이 방식의 장점:

- 수학적으로 직관적이며, 경우의 수 개념을 그대로 적용한 것입니다.

이 방식의 어려움 (구현 관점에서):

- 가능한 모든 조합 찾기: `c1*1 + c2*2 + c3*3 = n` 을 만족하는 음이 아닌 정수 c1, c2, c3의 모든 쌍을 체계적으로 찾는 과정이 필요합니다. 이는 보통 반복문을 통해 구현해야 하는데, 예를 들어 c3를 0부터 n/3까지, c2를 0부터 (n - 3*c3) / 2까지 반복하면서 c1을 계산하는 방식이 될 수 있습니다. 이 과정 자체가 n이 커지면 복잡해지고 계산량이 늘어납니다.
- 순열 계산 (다항 계수 계산): `(c1 + c2 + c3)! / (c1! * c2! * c3!)` 형태의 계산이 필요합니다. 문제는 n이 커지면 `(c1 + c2 + c3)!` 값이 매우 빠르게 커져서 일반적인 정수 자료형으로는 표현할 수 없게 오버플로우가 발생할 수 있습니다. 물론 분자와 분모를 적절히 나눠가며 계산하거나, 로그를 이용하는 등 오버플로우를 피하는 방법도 있지만, 구현이 훨씬 복잡해집니다.

따라서, 생각하신 방식은 이론적으로 맞지만, 컴퓨터 프로그램으로 구현하기에는 효율성이나 오버플로우 문제 때문에 다소 까다로울 수 있습니다.

## Dynamic Programming, DP를 이용한 풀이

`dp[i]` 라는 것을 만들어서 **"숫자 i를 1, 2, 3의 합으로 나타내는 경우의 수"** 라고 정의하는 거예요.

우리는 `dp[1]`, `dp[2]`, `dp[3]`부터 시작해서 차례대로 `dp[4]`, `dp[5]`, ... 쭉 계산해서 마지막에 `dp[n]`을 찾는 거죠.

자, `dp[i]` (숫자 i를 만드는 방법의 총 가짓수)를 어떻게 계산할까요?

어떤 합이 숫자 `i`가 되려면, 그 합의 **마지막에 더해지는 숫자는 반드시 1 또는 2 또는 3 중 하나**일 거예요. 다른 숫자는 사용할 수 없으니까요.

그러니까, `i`를 만드는 전체 방법은 다음 세 가지 경우를 합친 것과 같습니다.

1.  **맨 마지막에 1을 더해서 `i`가 되는 경우:**
    * 맨 마지막에 1을 더했다면, 1을 더하기 전까지의 합은 `i - 1`이 되었을 거예요.
    * 그렇다면 `i - 1`을 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '1'만 붙이면, `i`를 만들고 마지막이 1인 경우가 되는 거죠.
    * `i - 1`을 만드는 방법의 수는 우리가 이미 앞에서 계산해 놓은 `dp[i - 1]` 입니다.
    * **따라서, 마지막이 1인 경우의 수는 `dp[i - 1]`과 같습니다.**

2.  **맨 마지막에 2를 더해서 `i`가 되는 경우:**
    * 맨 마지막에 2를 더했다면, 2를 더하기 전까지의 합은 `i - 2`가 되었을 거예요.
    * `i - 2`를 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '2'만 붙이면, `i`를 만들고 마지막이 2인 경우가 됩니다.
    * `i - 2`를 만드는 방법의 수는 `dp[i - 2]` 입니다.
    * **따라서, 마지막이 2인 경우의 수는 `dp[i - 2]`와 같습니다.**

3.  **맨 마지막에 3을 더해서 `i`가 되는 경우:**
    * 맨 마지막에 3을 더했다면, 3을 더하기 전까지의 합은 `i - 3`이 되었을 거예요.
    * `i - 3`을 1, 2, 3의 합으로 만드는 모든 방법 뒤에 '3'만 붙이면, `i`를 만들고 마지막이 3인 경우가 됩니다.
    * `i - 3`을 만드는 방법의 수는 `dp[i - 3]` 입니다.
    * **따라서, 마지막이 3인 경우의 수는 `dp[i - 3]`과 같습니다.**

이 세 가지 경우는 겹치지 않으면서 `i`를 만드는 모든 방법을 다 포함합니다. (어떤 합이든 맨 마지막 숫자는 1, 2, 3 중 하나여야 하므로)

그래서, `i`를 만드는 전체 방법의 수 `dp[i]`는 이 세 가지 경우의 수를 모두 더한 것과 같습니다.

**`dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]`**

이게 바로 이 문제의 동적 계획법 **점화식**입니다.

**계산은 이렇게 진행됩니다:**

먼저 아주 작은 값들의 `dp` 값을 우리가 직접 세서 정해둡니다. 이걸 **기저 조건 (Base Case)**이라고 해요.

* `dp[0]`: 0을 만드는 방법? 아무것도 더하지 않는 1가지 방법이 있다고 약속합니다. (나중에 계산을 위해 필요해요). `dp[0] = 1`
* `dp[1]` : 1을 만드는 방법? `1` 하나. -> 1가지. `dp[1] = 1`
* `dp[2]` : 2를 만드는 방법? `1+1`, `2`. -> 2가지. `dp[2] = 2`
* `dp[3]` : 3을 만드는 방법? `1+1+1`, `1+2`, `2+1`, `3`. -> 4가지. `dp[3] = 4`

이제 점화식을 사용해서 차례대로 계산합니다.

* `dp[4]` = `dp[3] + dp[2] + dp[1]` = 4 + 2 + 1 = 7
    * (4를 만드는 방법은 3 만드는 방법 뒤에 1 붙이기 + 2 만드는 방법 뒤에 2 붙이기 + 1 만드는 방법 뒤에 3 붙이기)
* `dp[5]` = `dp[4] + dp[3] + dp[2]` = 7 + 4 + 2 = 13
* `dp[6]` = `dp[5] + dp[4] + dp[3]` = 13 + 7 + 4 = 24
    ... 이런 식으로 `dp[n]`까지 계산하면 됩니다.

단순히 바로 직전(i-1), 두 칸 앞(i-2), 세 칸 앞(i-3)에서 계산해 둔 값을 더하기만 하면 `dp[i]`가 바로 나옵니다. 계산 과정이 덧셈만 사용하므로 오버플로우 걱정도 훨씬 적고, 구현도 배열(list) 하나 만들고 반복문 돌면서 점화식 적용하는 식으로 아주 간단해집니다.